(*
   PostgreSQL-OCAML - OCaml-interface to the PostgreSQL database

   Copyright (C) 2004-  Markus Mottl
   email: markus.mottl@gmail.com
   WWW:   http://www.ocaml.info

   Copyright (C) 2001  Alain Frisch  (version: postgres-20010808)
   email: Alain.Frisch@ens.fr
   WWW:   http://www.eleves.ens.fr/home/frisch

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*)

open Printf

type oid = int
type large_object = int

exception Oid of oid

let invalid_oid = 0

type error_id = int
exception Error_field_name of error_id



module Error_field_name = struct
  type t =
    | PG_DIAG_SEVERITY
    | PG_DIAG_SEVERITY_NONLOCALIZED
    | PG_DIAG_SQLSTATE
    | PG_DIAG_MESSAGE_PRIMARY
    | PG_DIAG_MESSAGE_DETAIL
    | PG_DIAG_MESSAGE_HINT
    | PG_DIAG_STATEMENT_POSITION
    | PG_DIAG_INTERNAL_POSITION
    | PG_DIAG_INTERNAL_QUERY
    | PG_DIAG_CONTEXT
    | PG_DIAG_SCHEMA_NAME
    | PG_DIAG_TABLE_NAME
    | PG_DIAG_COLUMN_NAME
    | PG_DIAG_DATATYPE_NAME
    | PG_DIAG_CONSTRAINT_NAME
    | PG_DIAG_SOURCE_FILE
    | PG_DIAG_SOURCE_LINE
    | PG_DIAG_SOURCE_FUNCTION
end

module Error_code = struct
  type condition_name =
    | ACTIVE_SQL_TRANSACTION
    | ADMIN_SHUTDOWN
    | AMBIGUOUS_ALIAS
    | AMBIGUOUS_COLUMN
    | AMBIGUOUS_FUNCTION
    | AMBIGUOUS_PARAMETER
    | ARRAY_SUBSCRIPT_ERROR
    | ASSERT_FAILURE
    | BAD_COPY_FILE_FORMAT
    | BRANCH_TRANSACTION_ALREADY_ACTIVE
    | CANNOT_COERCE
    | CANNOT_CONNECT_NOW
    | CANT_CHANGE_RUNTIME_PARAM
    | CARDINALITY_VIOLATION
    | CASE_NOT_FOUND
    | CHARACTER_NOT_IN_REPERTOIRE
    | CHECK_VIOLATION
    | COLLATION_MISMATCH
    | CONFIGURATION_LIMIT_EXCEEDED
    | CONFIG_FILE_ERROR
    | CONNECTION_DOES_NOT_EXIST
    | CONNECTION_EXCEPTION
    | CONNECTION_FAILURE
    | CONTAINING_SQL_NOT_PERMITTED
    | CRASH_SHUTDOWN
    | DATABASE_DROPPED
    | DATATYPE_MISMATCH
    | DATA_CORRUPTED
    | DATA_EXCEPTION
    | DATETIME_FIELD_OVERFLOW
    | DEADLOCK_DETECTED
    | DEPENDENT_OBJECTS_STILL_EXIST
    | DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST
    | DEPRECATED_FEATURE
    | DIAGNOSTICS_EXCEPTION
    | DISK_FULL
    | DIVISION_BY_ZERO
    | DUPLICATE_ALIAS
    | DUPLICATE_COLUMN
    | DUPLICATE_CURSOR
    | DUPLICATE_DATABASE
    | DUPLICATE_FILE
    | DUPLICATE_FUNCTION
    | DUPLICATE_OBJECT
    | DUPLICATE_PREPARED_STATEMENT
    | DUPLICATE_SCHEMA
    | DUPLICATE_TABLE
    | DYNAMIC_RESULT_SETS_RETURNED
    | ERROR_IN_ASSIGNMENT
    | ESCAPE_CHARACTER_CONFLICT
    | EVENT_TRIGGER_PROTOCOL_VIOLATED
    | EXCLUSION_VIOLATION
    | EXTERNAL_ROUTINE_EXCEPTION
    | EXTERNAL_ROUTINE_INVOCATION_EXCEPTION
    | FDW_COLUMN_NAME_NOT_FOUND
    | FDW_DYNAMIC_PARAMETER_VALUE_NEEDED
    | FDW_ERROR
    | FDW_FUNCTION_SEQUENCE_ERROR
    | FDW_INCONSISTENT_DESCRIPTOR_INFORMATION
    | FDW_INVALID_ATTRIBUTE_VALUE
    | FDW_INVALID_COLUMN_NAME
    | FDW_INVALID_COLUMN_NUMBER
    | FDW_INVALID_DATA_TYPE
    | FDW_INVALID_DATA_TYPE_DESCRIPTORS
    | FDW_INVALID_DESCRIPTOR_FIELD_IDENTIFIER
    | FDW_INVALID_HANDLE
    | FDW_INVALID_OPTION_INDEX
    | FDW_INVALID_OPTION_NAME
    | FDW_INVALID_STRING_FORMAT
    | FDW_INVALID_STRING_LENGTH_OR_BUFFER_LENGTH
    | FDW_INVALID_USE_OF_NULL_POINTER
    | FDW_NO_SCHEMAS
    | FDW_OPTION_NAME_NOT_FOUND
    | FDW_OUT_OF_MEMORY
    | FDW_REPLY_HANDLE
    | FDW_SCHEMA_NOT_FOUND
    | FDW_TABLE_NOT_FOUND
    | FDW_TOO_MANY_HANDLES
    | FDW_UNABLE_TO_CREATE_EXECUTION
    | FDW_UNABLE_TO_CREATE_REPLY
    | FDW_UNABLE_TO_ESTABLISH_CONNECTION
    | FEATURE_NOT_SUPPORTED
    | FLOATING_POINT_EXCEPTION
    | FOREIGN_KEY_VIOLATION
    | FUNCTION_EXECUTED_NO_RETURN_STATEMENT
    | GENERATED_ALWAYS
    | GROUPING_ERROR
    | HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL
    | IDLE_IN_TRANSACTION_SESSION_TIMEOUT
    | IMPLICIT_ZERO_BIT_PADDING
    | INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION
    | INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION
    | INDETERMINATE_COLLATION
    | INDETERMINATE_DATATYPE
    | INDEX_CORRUPTED
    | INDICATOR_OVERFLOW
    | INSUFFICIENT_PRIVILEGE
    | INSUFFICIENT_RESOURCES
    | INTEGRITY_CONSTRAINT_VIOLATION
    | INTERNAL_ERROR
    | INTERVAL_FIELD_OVERFLOW
    | INVALID_ARGUMENT_FOR_LOGARITHM
    | INVALID_ARGUMENT_FOR_NTH_VALUE_FUNCTION
    | INVALID_ARGUMENT_FOR_NTILE_FUNCTION
    | INVALID_ARGUMENT_FOR_POWER_FUNCTION
    | INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION
    | INVALID_AUTHORIZATION_SPECIFICATION
    | INVALID_BINARY_REPRESENTATION
    | INVALID_CATALOG_NAME
    | INVALID_CHARACTER_VALUE_FOR_CAST
    | INVALID_COLUMN_DEFINITION
    | INVALID_COLUMN_REFERENCE
    | INVALID_CURSOR_DEFINITION
    | INVALID_CURSOR_NAME
    | INVALID_CURSOR_STATE
    | INVALID_DATABASE_DEFINITION
    | INVALID_DATETIME_FORMAT
    | INVALID_ESCAPE_CHARACTER
    | INVALID_ESCAPE_OCTET
    | INVALID_ESCAPE_SEQUENCE
    | INVALID_FOREIGN_KEY
    | INVALID_FUNCTION_DEFINITION
    | INVALID_GRANTOR
    | INVALID_GRANT_OPERATION
    | INVALID_INDICATOR_PARAMETER_VALUE
    | INVALID_LOCATOR_SPECIFICATION
    | INVALID_NAME
    | INVALID_OBJECT_DEFINITION
    | INVALID_PARAMETER_VALUE
    | INVALID_PASSWORD
    | INVALID_PREPARED_STATEMENT_DEFINITION
    | INVALID_RECURSION
    | INVALID_REGULAR_EXPRESSION
    | INVALID_ROLE_SPECIFICATION
    | INVALID_ROW_COUNT_IN_LIMIT_CLAUSE
    | INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE
    | INVALID_SAVEPOINT_SPECIFICATION
    | INVALID_SCHEMA_DEFINITION
    | INVALID_SCHEMA_NAME
    | INVALID_SQLSTATE_RETURNED
    | INVALID_SQL_STATEMENT_NAME
    | INVALID_TABLESAMPLE_ARGUMENT
    | INVALID_TABLESAMPLE_REPEAT
    | INVALID_TABLE_DEFINITION
    | INVALID_TEXT_REPRESENTATION
    | INVALID_TIME_ZONE_DISPLACEMENT_VALUE
    | INVALID_TRANSACTION_INITIATION
    | INVALID_TRANSACTION_STATE
    | INVALID_TRANSACTION_TERMINATION
    | INVALID_USE_OF_ESCAPE_CHARACTER
    | INVALID_XML_COMMENT
    | INVALID_XML_CONTENT
    | INVALID_XML_DOCUMENT
    | INVALID_XML_PROCESSING_INSTRUCTION
    | IN_FAILED_SQL_TRANSACTION
    | IO_ERROR
    | LOCATOR_EXCEPTION
    | LOCK_FILE_EXISTS
    | LOCK_NOT_AVAILABLE
    | MODIFYING_SQL_DATA_NOT_PERMITTED
    | MOST_SPECIFIC_TYPE_MISMATCH
    | NAME_TOO_LONG
    | NONSTANDARD_USE_OF_ESCAPE_CHARACTER
    | NOT_AN_XML_DOCUMENT
    | NOT_NULL_VIOLATION
    | NO_ACTIVE_SQL_TRANSACTION
    | NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION
    | NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED
    | NO_DATA
    | NO_DATA_FOUND
    | NULL_VALUE_ELIMINATED_IN_SET_FUNCTION
    | NULL_VALUE_NOT_ALLOWED
    | NULL_VALUE_NO_INDICATOR_PARAMETER
    | NUMERIC_VALUE_OUT_OF_RANGE
    | OBJECT_IN_USE
    | OBJECT_NOT_IN_PREREQUISITE_STATE
    | OPERATOR_INTERVENTION
    | OUT_OF_MEMORY
    | PLPGSQL_ERROR
    | PRIVILEGE_NOT_GRANTED
    | PRIVILEGE_NOT_REVOKED
    | PROGRAM_LIMIT_EXCEEDED
    | PROHIBITED_SQL_STATEMENT_ATTEMPTED
    | PROTOCOL_VIOLATION
    | QUERY_CANCELED
    | RAISE_EXCEPTION
    | READING_SQL_DATA_NOT_PERMITTED
    | READ_ONLY_SQL_TRANSACTION
    | RESERVED_NAME
    | RESTRICT_VIOLATION
    | SAVEPOINT_EXCEPTION
    | SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED
    | SEQUENCE_GENERATOR_LIMIT_EXCEEDED
    | SERIALIZATION_FAILURE
    | SNAPSHOT_TOO_OLD
    | SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION
    | SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION
    | SQL_ROUTINE_EXCEPTION
    | SQL_STATEMENT_NOT_YET_COMPLETE
    | SRF_PROTOCOL_VIOLATED
    | STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER
    | STATEMENT_COMPLETION_UNKNOWN
    | STATEMENT_TOO_COMPLEX
    | STRING_DATA_LENGTH_MISMATCH
    | STRING_DATA_RIGHT_TRUNCATION
    | SUBSTRING_ERROR
    | SUCCESSFUL_COMPLETION
    | SYNTAX_ERROR
    | SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION
    | SYSTEM_ERROR
    | TOO_MANY_ARGUMENTS
    | TOO_MANY_COLUMNS
    | TOO_MANY_CONNECTIONS
    | TOO_MANY_ROWS
    | TRANSACTION_INTEGRITY_CONSTRAINT_VIOLATION
    | TRANSACTION_RESOLUTION_UNKNOWN
    | TRANSACTION_ROLLBACK
    | TRIGGERED_ACTION_EXCEPTION
    | TRIGGERED_DATA_CHANGE_VIOLATION
    | TRIGGER_PROTOCOL_VIOLATED
    | TRIM_ERROR
    | UNDEFINED_COLUMN
    | UNDEFINED_FILE
    | UNDEFINED_FUNCTION
    | UNDEFINED_OBJECT
    | UNDEFINED_PARAMETER
    | UNDEFINED_TABLE
    | UNIQUE_VIOLATION
    | UNTERMINATED_C_STRING
    | UNTRANSLATABLE_CHARACTER
    | WARNING
    | WINDOWING_ERROR
    | WITH_CHECK_OPTION_VIOLATION
    | WRONG_OBJECT_TYPE
    | ZERO_LENGTH_CHARACTER_STRING

  let string_of_condition_name condition_name =
    match condition_name with
    | SUCCESSFUL_COMPLETION -> "SUCCESSFUL_COMPLETION"
    | WARNING -> "WARNING"
    | DYNAMIC_RESULT_SETS_RETURNED -> "DYNAMIC_RESULT_SETS_RETURNED"
    | IMPLICIT_ZERO_BIT_PADDING -> "IMPLICIT_ZERO_BIT_PADDING"
    | NULL_VALUE_ELIMINATED_IN_SET_FUNCTION -> "NULL_VALUE_ELIMINATED_IN_SET_FUNCTION"
    | PRIVILEGE_NOT_GRANTED -> "PRIVILEGE_NOT_GRANTED"
    | PRIVILEGE_NOT_REVOKED -> "PRIVILEGE_NOT_REVOKED"
    | STRING_DATA_RIGHT_TRUNCATION -> "STRING_DATA_RIGHT_TRUNCATION"
    | DEPRECATED_FEATURE -> "DEPRECATED_FEATURE"
    | NO_DATA -> "NO_DATA"
    | NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED -> "NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED"
    | SQL_STATEMENT_NOT_YET_COMPLETE -> "SQL_STATEMENT_NOT_YET_COMPLETE"
    | CONNECTION_EXCEPTION -> "CONNECTION_EXCEPTION"
    | CONNECTION_DOES_NOT_EXIST -> "CONNECTION_DOES_NOT_EXIST"
    | CONNECTION_FAILURE -> "CONNECTION_FAILURE"
    | SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION -> "SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION"
    | SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION -> "SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION"
    | TRANSACTION_RESOLUTION_UNKNOWN -> "TRANSACTION_RESOLUTION_UNKNOWN"
    | PROTOCOL_VIOLATION -> "PROTOCOL_VIOLATION"
    | TRIGGERED_ACTION_EXCEPTION -> "TRIGGERED_ACTION_EXCEPTION"
    | FEATURE_NOT_SUPPORTED -> "FEATURE_NOT_SUPPORTED"
    | INVALID_TRANSACTION_INITIATION -> "INVALID_TRANSACTION_INITIATION"
    | LOCATOR_EXCEPTION -> "LOCATOR_EXCEPTION"
    | INVALID_LOCATOR_SPECIFICATION -> "INVALID_LOCATOR_SPECIFICATION"
    | INVALID_GRANTOR -> "INVALID_GRANTOR"
    | INVALID_GRANT_OPERATION -> "INVALID_GRANT_OPERATION"
    | INVALID_ROLE_SPECIFICATION -> "INVALID_ROLE_SPECIFICATION"
    | DIAGNOSTICS_EXCEPTION -> "DIAGNOSTICS_EXCEPTION"
    | STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER -> "STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER"
    | CASE_NOT_FOUND -> "CASE_NOT_FOUND"
    | CARDINALITY_VIOLATION -> "CARDINALITY_VIOLATION"
    | DATA_EXCEPTION -> "DATA_EXCEPTION"
    | ARRAY_SUBSCRIPT_ERROR -> "ARRAY_SUBSCRIPT_ERROR"
    | CHARACTER_NOT_IN_REPERTOIRE -> "CHARACTER_NOT_IN_REPERTOIRE"
    | DATETIME_FIELD_OVERFLOW -> "DATETIME_FIELD_OVERFLOW"
    | DIVISION_BY_ZERO -> "DIVISION_BY_ZERO"
    | ERROR_IN_ASSIGNMENT -> "ERROR_IN_ASSIGNMENT"
    | ESCAPE_CHARACTER_CONFLICT -> "ESCAPE_CHARACTER_CONFLICT"
    | INDICATOR_OVERFLOW -> "INDICATOR_OVERFLOW"
    | INTERVAL_FIELD_OVERFLOW -> "INTERVAL_FIELD_OVERFLOW"
    | INVALID_ARGUMENT_FOR_LOGARITHM -> "INVALID_ARGUMENT_FOR_LOGARITHM"
    | INVALID_ARGUMENT_FOR_NTILE_FUNCTION -> "INVALID_ARGUMENT_FOR_NTILE_FUNCTION"
    | INVALID_ARGUMENT_FOR_NTH_VALUE_FUNCTION -> "INVALID_ARGUMENT_FOR_NTH_VALUE_FUNCTION"
    | INVALID_ARGUMENT_FOR_POWER_FUNCTION -> "INVALID_ARGUMENT_FOR_POWER_FUNCTION"
    | INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION -> "INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION"
    | INVALID_CHARACTER_VALUE_FOR_CAST -> "INVALID_CHARACTER_VALUE_FOR_CAST"
    | INVALID_DATETIME_FORMAT -> "INVALID_DATETIME_FORMAT"
    | INVALID_ESCAPE_CHARACTER -> "INVALID_ESCAPE_CHARACTER"
    | INVALID_ESCAPE_OCTET -> "INVALID_ESCAPE_OCTET"
    | INVALID_ESCAPE_SEQUENCE -> "INVALID_ESCAPE_SEQUENCE"
    | NONSTANDARD_USE_OF_ESCAPE_CHARACTER -> "NONSTANDARD_USE_OF_ESCAPE_CHARACTER"
    | INVALID_INDICATOR_PARAMETER_VALUE -> "INVALID_INDICATOR_PARAMETER_VALUE"
    | INVALID_PARAMETER_VALUE -> "INVALID_PARAMETER_VALUE"
    | INVALID_REGULAR_EXPRESSION -> "INVALID_REGULAR_EXPRESSION"
    | INVALID_ROW_COUNT_IN_LIMIT_CLAUSE -> "INVALID_ROW_COUNT_IN_LIMIT_CLAUSE"
    | INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE -> "INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE"
    | INVALID_TABLESAMPLE_ARGUMENT -> "INVALID_TABLESAMPLE_ARGUMENT"
    | INVALID_TABLESAMPLE_REPEAT -> "INVALID_TABLESAMPLE_REPEAT"
    | INVALID_TIME_ZONE_DISPLACEMENT_VALUE -> "INVALID_TIME_ZONE_DISPLACEMENT_VALUE"
    | INVALID_USE_OF_ESCAPE_CHARACTER -> "INVALID_USE_OF_ESCAPE_CHARACTER"
    | MOST_SPECIFIC_TYPE_MISMATCH -> "MOST_SPECIFIC_TYPE_MISMATCH"
    | NULL_VALUE_NOT_ALLOWED -> "NULL_VALUE_NOT_ALLOWED"
    | NULL_VALUE_NO_INDICATOR_PARAMETER -> "NULL_VALUE_NO_INDICATOR_PARAMETER"
    | NUMERIC_VALUE_OUT_OF_RANGE -> "NUMERIC_VALUE_OUT_OF_RANGE"
    | SEQUENCE_GENERATOR_LIMIT_EXCEEDED -> "SEQUENCE_GENERATOR_LIMIT_EXCEEDED"
    | STRING_DATA_LENGTH_MISMATCH -> "STRING_DATA_LENGTH_MISMATCH"
    | SUBSTRING_ERROR -> "SUBSTRING_ERROR"
    | TRIM_ERROR -> "TRIM_ERROR"
    | UNTERMINATED_C_STRING -> "UNTERMINATED_C_STRING"
    | ZERO_LENGTH_CHARACTER_STRING -> "ZERO_LENGTH_CHARACTER_STRING"
    | FLOATING_POINT_EXCEPTION -> "FLOATING_POINT_EXCEPTION"
    | INVALID_TEXT_REPRESENTATION -> "INVALID_TEXT_REPRESENTATION"
    | INVALID_BINARY_REPRESENTATION -> "INVALID_BINARY_REPRESENTATION"
    | BAD_COPY_FILE_FORMAT -> "BAD_COPY_FILE_FORMAT"
    | UNTRANSLATABLE_CHARACTER -> "UNTRANSLATABLE_CHARACTER"
    | NOT_AN_XML_DOCUMENT -> "NOT_AN_XML_DOCUMENT"
    | INVALID_XML_DOCUMENT -> "INVALID_XML_DOCUMENT"
    | INVALID_XML_CONTENT -> "INVALID_XML_CONTENT"
    | INVALID_XML_COMMENT -> "INVALID_XML_COMMENT"
    | INVALID_XML_PROCESSING_INSTRUCTION -> "INVALID_XML_PROCESSING_INSTRUCTION"
    | INTEGRITY_CONSTRAINT_VIOLATION -> "INTEGRITY_CONSTRAINT_VIOLATION"
    | RESTRICT_VIOLATION -> "RESTRICT_VIOLATION"
    | NOT_NULL_VIOLATION -> "NOT_NULL_VIOLATION"
    | FOREIGN_KEY_VIOLATION -> "FOREIGN_KEY_VIOLATION"
    | UNIQUE_VIOLATION -> "UNIQUE_VIOLATION"
    | CHECK_VIOLATION -> "CHECK_VIOLATION"
    | EXCLUSION_VIOLATION -> "EXCLUSION_VIOLATION"
    | INVALID_CURSOR_STATE -> "INVALID_CURSOR_STATE"
    | INVALID_TRANSACTION_STATE -> "INVALID_TRANSACTION_STATE"
    | ACTIVE_SQL_TRANSACTION -> "ACTIVE_SQL_TRANSACTION"
    | BRANCH_TRANSACTION_ALREADY_ACTIVE -> "BRANCH_TRANSACTION_ALREADY_ACTIVE"
    | HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL -> "HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL"
    | INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION -> "INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION"
    | INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION -> "INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION"
    | NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION -> "NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION"
    | READ_ONLY_SQL_TRANSACTION -> "READ_ONLY_SQL_TRANSACTION"
    | SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED -> "SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED"
    | NO_ACTIVE_SQL_TRANSACTION -> "NO_ACTIVE_SQL_TRANSACTION"
    | IN_FAILED_SQL_TRANSACTION -> "IN_FAILED_SQL_TRANSACTION"
    | IDLE_IN_TRANSACTION_SESSION_TIMEOUT -> "IDLE_IN_TRANSACTION_SESSION_TIMEOUT"
    | INVALID_SQL_STATEMENT_NAME -> "INVALID_SQL_STATEMENT_NAME"
    | TRIGGERED_DATA_CHANGE_VIOLATION -> "TRIGGERED_DATA_CHANGE_VIOLATION"
    | INVALID_AUTHORIZATION_SPECIFICATION -> "INVALID_AUTHORIZATION_SPECIFICATION"
    | INVALID_PASSWORD -> "INVALID_PASSWORD"
    | DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST -> "DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST"
    | DEPENDENT_OBJECTS_STILL_EXIST -> "DEPENDENT_OBJECTS_STILL_EXIST"
    | INVALID_TRANSACTION_TERMINATION -> "INVALID_TRANSACTION_TERMINATION"
    | SQL_ROUTINE_EXCEPTION -> "SQL_ROUTINE_EXCEPTION"
    | FUNCTION_EXECUTED_NO_RETURN_STATEMENT -> "FUNCTION_EXECUTED_NO_RETURN_STATEMENT"
    | MODIFYING_SQL_DATA_NOT_PERMITTED -> "MODIFYING_SQL_DATA_NOT_PERMITTED"
    | PROHIBITED_SQL_STATEMENT_ATTEMPTED -> "PROHIBITED_SQL_STATEMENT_ATTEMPTED"
    | READING_SQL_DATA_NOT_PERMITTED -> "READING_SQL_DATA_NOT_PERMITTED"
    | INVALID_CURSOR_NAME -> "INVALID_CURSOR_NAME"
    | EXTERNAL_ROUTINE_EXCEPTION -> "EXTERNAL_ROUTINE_EXCEPTION"
    | CONTAINING_SQL_NOT_PERMITTED -> "CONTAINING_SQL_NOT_PERMITTED"
    | MODIFYING_SQL_DATA_NOT_PERMITTED -> "MODIFYING_SQL_DATA_NOT_PERMITTED"
    | PROHIBITED_SQL_STATEMENT_ATTEMPTED -> "PROHIBITED_SQL_STATEMENT_ATTEMPTED"
    | READING_SQL_DATA_NOT_PERMITTED -> "READING_SQL_DATA_NOT_PERMITTED"
    | EXTERNAL_ROUTINE_INVOCATION_EXCEPTION -> "EXTERNAL_ROUTINE_INVOCATION_EXCEPTION"
    | INVALID_SQLSTATE_RETURNED -> "INVALID_SQLSTATE_RETURNED"
    | NULL_VALUE_NOT_ALLOWED -> "NULL_VALUE_NOT_ALLOWED"
    | TRIGGER_PROTOCOL_VIOLATED -> "TRIGGER_PROTOCOL_VIOLATED"
    | SRF_PROTOCOL_VIOLATED -> "SRF_PROTOCOL_VIOLATED"
    | EVENT_TRIGGER_PROTOCOL_VIOLATED -> "EVENT_TRIGGER_PROTOCOL_VIOLATED"
    | SAVEPOINT_EXCEPTION -> "SAVEPOINT_EXCEPTION"
    | INVALID_SAVEPOINT_SPECIFICATION -> "INVALID_SAVEPOINT_SPECIFICATION"
    | INVALID_CATALOG_NAME -> "INVALID_CATALOG_NAME"
    | INVALID_SCHEMA_NAME -> "INVALID_SCHEMA_NAME"
    | TRANSACTION_ROLLBACK -> "TRANSACTION_ROLLBACK"
    | TRANSACTION_INTEGRITY_CONSTRAINT_VIOLATION -> "TRANSACTION_INTEGRITY_CONSTRAINT_VIOLATION"
    | SERIALIZATION_FAILURE -> "SERIALIZATION_FAILURE"
    | STATEMENT_COMPLETION_UNKNOWN -> "STATEMENT_COMPLETION_UNKNOWN"
    | DEADLOCK_DETECTED -> "DEADLOCK_DETECTED"
    | SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION -> "SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION"
    | SYNTAX_ERROR -> "SYNTAX_ERROR"
    | INSUFFICIENT_PRIVILEGE -> "INSUFFICIENT_PRIVILEGE"
    | CANNOT_COERCE -> "CANNOT_COERCE"
    | GROUPING_ERROR -> "GROUPING_ERROR"
    | WINDOWING_ERROR -> "WINDOWING_ERROR"
    | INVALID_RECURSION -> "INVALID_RECURSION"
    | INVALID_FOREIGN_KEY -> "INVALID_FOREIGN_KEY"
    | INVALID_NAME -> "INVALID_NAME"
    | NAME_TOO_LONG -> "NAME_TOO_LONG"
    | RESERVED_NAME -> "RESERVED_NAME"
    | DATATYPE_MISMATCH -> "DATATYPE_MISMATCH"
    | INDETERMINATE_DATATYPE -> "INDETERMINATE_DATATYPE"
    | COLLATION_MISMATCH -> "COLLATION_MISMATCH"
    | INDETERMINATE_COLLATION -> "INDETERMINATE_COLLATION"
    | WRONG_OBJECT_TYPE -> "WRONG_OBJECT_TYPE"
    | GENERATED_ALWAYS -> "GENERATED_ALWAYS"
    | UNDEFINED_COLUMN -> "UNDEFINED_COLUMN"
    | UNDEFINED_FUNCTION -> "UNDEFINED_FUNCTION"
    | UNDEFINED_TABLE -> "UNDEFINED_TABLE"
    | UNDEFINED_PARAMETER -> "UNDEFINED_PARAMETER"
    | UNDEFINED_OBJECT -> "UNDEFINED_OBJECT"
    | DUPLICATE_COLUMN -> "DUPLICATE_COLUMN"
    | DUPLICATE_CURSOR -> "DUPLICATE_CURSOR"
    | DUPLICATE_DATABASE -> "DUPLICATE_DATABASE"
    | DUPLICATE_FUNCTION -> "DUPLICATE_FUNCTION"
    | DUPLICATE_PREPARED_STATEMENT -> "DUPLICATE_PREPARED_STATEMENT"
    | DUPLICATE_SCHEMA -> "DUPLICATE_SCHEMA"
    | DUPLICATE_TABLE -> "DUPLICATE_TABLE"
    | DUPLICATE_ALIAS -> "DUPLICATE_ALIAS"
    | DUPLICATE_OBJECT -> "DUPLICATE_OBJECT"
    | AMBIGUOUS_COLUMN -> "AMBIGUOUS_COLUMN"
    | AMBIGUOUS_FUNCTION -> "AMBIGUOUS_FUNCTION"
    | AMBIGUOUS_PARAMETER -> "AMBIGUOUS_PARAMETER"
    | AMBIGUOUS_ALIAS -> "AMBIGUOUS_ALIAS"
    | INVALID_COLUMN_REFERENCE -> "INVALID_COLUMN_REFERENCE"
    | INVALID_COLUMN_DEFINITION -> "INVALID_COLUMN_DEFINITION"
    | INVALID_CURSOR_DEFINITION -> "INVALID_CURSOR_DEFINITION"
    | INVALID_DATABASE_DEFINITION -> "INVALID_DATABASE_DEFINITION"
    | INVALID_FUNCTION_DEFINITION -> "INVALID_FUNCTION_DEFINITION"
    | INVALID_PREPARED_STATEMENT_DEFINITION -> "INVALID_PREPARED_STATEMENT_DEFINITION"
    | INVALID_SCHEMA_DEFINITION -> "INVALID_SCHEMA_DEFINITION"
    | INVALID_TABLE_DEFINITION -> "INVALID_TABLE_DEFINITION"
    | INVALID_OBJECT_DEFINITION -> "INVALID_OBJECT_DEFINITION"
    | WITH_CHECK_OPTION_VIOLATION -> "WITH_CHECK_OPTION_VIOLATION"
    | INSUFFICIENT_RESOURCES -> "INSUFFICIENT_RESOURCES"
    | DISK_FULL -> "DISK_FULL"
    | OUT_OF_MEMORY -> "OUT_OF_MEMORY"
    | TOO_MANY_CONNECTIONS -> "TOO_MANY_CONNECTIONS"
    | CONFIGURATION_LIMIT_EXCEEDED -> "CONFIGURATION_LIMIT_EXCEEDED"
    | PROGRAM_LIMIT_EXCEEDED -> "PROGRAM_LIMIT_EXCEEDED"
    | STATEMENT_TOO_COMPLEX -> "STATEMENT_TOO_COMPLEX"
    | TOO_MANY_COLUMNS -> "TOO_MANY_COLUMNS"
    | TOO_MANY_ARGUMENTS -> "TOO_MANY_ARGUMENTS"
    | OBJECT_NOT_IN_PREREQUISITE_STATE -> "OBJECT_NOT_IN_PREREQUISITE_STATE"
    | OBJECT_IN_USE -> "OBJECT_IN_USE"
    | CANT_CHANGE_RUNTIME_PARAM -> "CANT_CHANGE_RUNTIME_PARAM"
    | LOCK_NOT_AVAILABLE -> "LOCK_NOT_AVAILABLE"
    | OPERATOR_INTERVENTION -> "OPERATOR_INTERVENTION"
    | QUERY_CANCELED -> "QUERY_CANCELED"
    | ADMIN_SHUTDOWN -> "ADMIN_SHUTDOWN"
    | CRASH_SHUTDOWN -> "CRASH_SHUTDOWN"
    | CANNOT_CONNECT_NOW -> "CANNOT_CONNECT_NOW"
    | DATABASE_DROPPED -> "DATABASE_DROPPED"
    | SYSTEM_ERROR -> "SYSTEM_ERROR"
    | IO_ERROR -> "IO_ERROR"
    | UNDEFINED_FILE -> "UNDEFINED_FILE"
    | DUPLICATE_FILE -> "DUPLICATE_FILE"
    | SNAPSHOT_TOO_OLD -> "SNAPSHOT_TOO_OLD"
    | CONFIG_FILE_ERROR -> "CONFIG_FILE_ERROR"
    | LOCK_FILE_EXISTS -> "LOCK_FILE_EXISTS"
    | FDW_ERROR -> "FDW_ERROR"
    | FDW_COLUMN_NAME_NOT_FOUND -> "FDW_COLUMN_NAME_NOT_FOUND"
    | FDW_DYNAMIC_PARAMETER_VALUE_NEEDED -> "FDW_DYNAMIC_PARAMETER_VALUE_NEEDED"
    | FDW_FUNCTION_SEQUENCE_ERROR -> "FDW_FUNCTION_SEQUENCE_ERROR"
    | FDW_INCONSISTENT_DESCRIPTOR_INFORMATION -> "FDW_INCONSISTENT_DESCRIPTOR_INFORMATION"
    | FDW_INVALID_ATTRIBUTE_VALUE -> "FDW_INVALID_ATTRIBUTE_VALUE"
    | FDW_INVALID_COLUMN_NAME -> "FDW_INVALID_COLUMN_NAME"
    | FDW_INVALID_COLUMN_NUMBER -> "FDW_INVALID_COLUMN_NUMBER"
    | FDW_INVALID_DATA_TYPE -> "FDW_INVALID_DATA_TYPE"
    | FDW_INVALID_DATA_TYPE_DESCRIPTORS -> "FDW_INVALID_DATA_TYPE_DESCRIPTORS"
    | FDW_INVALID_DESCRIPTOR_FIELD_IDENTIFIER -> "FDW_INVALID_DESCRIPTOR_FIELD_IDENTIFIER"
    | FDW_INVALID_HANDLE -> "FDW_INVALID_HANDLE"
    | FDW_INVALID_OPTION_INDEX -> "FDW_INVALID_OPTION_INDEX"
    | FDW_INVALID_OPTION_NAME -> "FDW_INVALID_OPTION_NAME"
    | FDW_INVALID_STRING_LENGTH_OR_BUFFER_LENGTH -> "FDW_INVALID_STRING_LENGTH_OR_BUFFER_LENGTH"
    | FDW_INVALID_STRING_FORMAT -> "FDW_INVALID_STRING_FORMAT"
    | FDW_INVALID_USE_OF_NULL_POINTER -> "FDW_INVALID_USE_OF_NULL_POINTER"
    | FDW_TOO_MANY_HANDLES -> "FDW_TOO_MANY_HANDLES"
    | FDW_OUT_OF_MEMORY -> "FDW_OUT_OF_MEMORY"
    | FDW_NO_SCHEMAS -> "FDW_NO_SCHEMAS"
    | FDW_OPTION_NAME_NOT_FOUND -> "FDW_OPTION_NAME_NOT_FOUND"
    | FDW_REPLY_HANDLE -> "FDW_REPLY_HANDLE"
    | FDW_SCHEMA_NOT_FOUND -> "FDW_SCHEMA_NOT_FOUND"
    | FDW_TABLE_NOT_FOUND -> "FDW_TABLE_NOT_FOUND"
    | FDW_UNABLE_TO_CREATE_EXECUTION -> "FDW_UNABLE_TO_CREATE_EXECUTION"
    | FDW_UNABLE_TO_CREATE_REPLY -> "FDW_UNABLE_TO_CREATE_REPLY"
    | FDW_UNABLE_TO_ESTABLISH_CONNECTION -> "FDW_UNABLE_TO_ESTABLISH_CONNECTION"
    | PLPGSQL_ERROR -> "PLPGSQL_ERROR"
    | RAISE_EXCEPTION -> "RAISE_EXCEPTION"
    | NO_DATA_FOUND -> "NO_DATA_FOUND"
    | TOO_MANY_ROWS -> "TOO_MANY_ROWS"
    | ASSERT_FAILURE -> "ASSERT_FAILURE"
    | INTERNAL_ERROR -> "INTERNAL_ERROR"
    | DATA_CORRUPTED -> "DATA_CORRUPTED"
    | INDEX_CORRUPTED -> "INDEX_CORRUPTED"

  let condition_name_of_error_code error_code : condition_name =
    match error_code with
    | "00000" -> SUCCESSFUL_COMPLETION
    | "01000" -> WARNING
    | "0100C" -> DYNAMIC_RESULT_SETS_RETURNED
    | "01008" -> IMPLICIT_ZERO_BIT_PADDING
    | "01003" -> NULL_VALUE_ELIMINATED_IN_SET_FUNCTION
    | "01007" -> PRIVILEGE_NOT_GRANTED
    | "01006" -> PRIVILEGE_NOT_REVOKED
    | "01004" -> STRING_DATA_RIGHT_TRUNCATION
    | "01P01" -> DEPRECATED_FEATURE
    | "02000" -> NO_DATA
    | "02001" -> NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED
    | "03000" -> SQL_STATEMENT_NOT_YET_COMPLETE
    | "08000" -> CONNECTION_EXCEPTION
    | "08003" -> CONNECTION_DOES_NOT_EXIST
    | "08006" -> CONNECTION_FAILURE
    | "08001" -> SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION
    | "08004" -> SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION
    | "08007" -> TRANSACTION_RESOLUTION_UNKNOWN
    | "08P01" -> PROTOCOL_VIOLATION
    | "09000" -> TRIGGERED_ACTION_EXCEPTION
    | "0A000" -> FEATURE_NOT_SUPPORTED
    | "0B000" -> INVALID_TRANSACTION_INITIATION
    | "0F000" -> LOCATOR_EXCEPTION
    | "0F001" -> INVALID_LOCATOR_SPECIFICATION
    | "0L000" -> INVALID_GRANTOR
    | "0LP01" -> INVALID_GRANT_OPERATION
    | "0P000" -> INVALID_ROLE_SPECIFICATION
    | "0Z000" -> DIAGNOSTICS_EXCEPTION
    | "0Z002" -> STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER
    | "20000" -> CASE_NOT_FOUND
    | "21000" -> CARDINALITY_VIOLATION
    | "22000" -> DATA_EXCEPTION
    | "2202E" -> ARRAY_SUBSCRIPT_ERROR
    | "22021" -> CHARACTER_NOT_IN_REPERTOIRE
    | "22008" -> DATETIME_FIELD_OVERFLOW
    | "22012" -> DIVISION_BY_ZERO
    | "22005" -> ERROR_IN_ASSIGNMENT
    | "2200B" -> ESCAPE_CHARACTER_CONFLICT
    | "22022" -> INDICATOR_OVERFLOW
    | "22015" -> INTERVAL_FIELD_OVERFLOW
    | "2201E" -> INVALID_ARGUMENT_FOR_LOGARITHM
    | "22014" -> INVALID_ARGUMENT_FOR_NTILE_FUNCTION
    | "22016" -> INVALID_ARGUMENT_FOR_NTH_VALUE_FUNCTION
    | "2201F" -> INVALID_ARGUMENT_FOR_POWER_FUNCTION
    | "2201G" -> INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION
    | "22018" -> INVALID_CHARACTER_VALUE_FOR_CAST
    | "22007" -> INVALID_DATETIME_FORMAT
    | "22019" -> INVALID_ESCAPE_CHARACTER
    | "2200D" -> INVALID_ESCAPE_OCTET
    | "22025" -> INVALID_ESCAPE_SEQUENCE
    | "22P06" -> NONSTANDARD_USE_OF_ESCAPE_CHARACTER
    | "22010" -> INVALID_INDICATOR_PARAMETER_VALUE
    | "22023" -> INVALID_PARAMETER_VALUE
    | "2201B" -> INVALID_REGULAR_EXPRESSION
    | "2201W" -> INVALID_ROW_COUNT_IN_LIMIT_CLAUSE
    | "2201X" -> INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE
    | "2202H" -> INVALID_TABLESAMPLE_ARGUMENT
    | "2202G" -> INVALID_TABLESAMPLE_REPEAT
    | "22009" -> INVALID_TIME_ZONE_DISPLACEMENT_VALUE
    | "2200C" -> INVALID_USE_OF_ESCAPE_CHARACTER
    | "2200G" -> MOST_SPECIFIC_TYPE_MISMATCH
    | "22004" -> NULL_VALUE_NOT_ALLOWED
    | "22002" -> NULL_VALUE_NO_INDICATOR_PARAMETER
    | "22003" -> NUMERIC_VALUE_OUT_OF_RANGE
    | "2200H" -> SEQUENCE_GENERATOR_LIMIT_EXCEEDED
    | "22026" -> STRING_DATA_LENGTH_MISMATCH
    | "22001" -> STRING_DATA_RIGHT_TRUNCATION
    | "22011" -> SUBSTRING_ERROR
    | "22027" -> TRIM_ERROR
    | "22024" -> UNTERMINATED_C_STRING
    | "2200F" -> ZERO_LENGTH_CHARACTER_STRING
    | "22P01" -> FLOATING_POINT_EXCEPTION
    | "22P02" -> INVALID_TEXT_REPRESENTATION
    | "22P03" -> INVALID_BINARY_REPRESENTATION
    | "22P04" -> BAD_COPY_FILE_FORMAT
    | "22P05" -> UNTRANSLATABLE_CHARACTER
    | "2200L" -> NOT_AN_XML_DOCUMENT
    | "2200M" -> INVALID_XML_DOCUMENT
    | "2200N" -> INVALID_XML_CONTENT
    | "2200S" -> INVALID_XML_COMMENT
    | "2200T" -> INVALID_XML_PROCESSING_INSTRUCTION
    | "23000" -> INTEGRITY_CONSTRAINT_VIOLATION
    | "23001" -> RESTRICT_VIOLATION
    | "23502" -> NOT_NULL_VIOLATION
    | "23503" -> FOREIGN_KEY_VIOLATION
    | "23505" -> UNIQUE_VIOLATION
    | "23514" -> CHECK_VIOLATION
    | "23P01" -> EXCLUSION_VIOLATION
    | "24000" -> INVALID_CURSOR_STATE
    | "25000" -> INVALID_TRANSACTION_STATE
    | "25001" -> ACTIVE_SQL_TRANSACTION
    | "25002" -> BRANCH_TRANSACTION_ALREADY_ACTIVE
    | "25008" -> HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL
    | "25003" -> INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION
    | "25004" -> INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION
    | "25005" -> NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION
    | "25006" -> READ_ONLY_SQL_TRANSACTION
    | "25007" -> SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED
    | "25P01" -> NO_ACTIVE_SQL_TRANSACTION
    | "25P02" -> IN_FAILED_SQL_TRANSACTION
    | "25P03" -> IDLE_IN_TRANSACTION_SESSION_TIMEOUT
    | "26000" -> INVALID_SQL_STATEMENT_NAME
    | "27000" -> TRIGGERED_DATA_CHANGE_VIOLATION
    | "28000" -> INVALID_AUTHORIZATION_SPECIFICATION
    | "28P01" -> INVALID_PASSWORD
    | "2B000" -> DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST
    | "2BP01" -> DEPENDENT_OBJECTS_STILL_EXIST
    | "2D000" -> INVALID_TRANSACTION_TERMINATION
    | "2F000" -> SQL_ROUTINE_EXCEPTION
    | "2F005" -> FUNCTION_EXECUTED_NO_RETURN_STATEMENT
    | "2F002" -> MODIFYING_SQL_DATA_NOT_PERMITTED
    | "2F003" -> PROHIBITED_SQL_STATEMENT_ATTEMPTED
    | "2F004" -> READING_SQL_DATA_NOT_PERMITTED
    | "34000" -> INVALID_CURSOR_NAME
    | "38000" -> EXTERNAL_ROUTINE_EXCEPTION
    | "38001" -> CONTAINING_SQL_NOT_PERMITTED
    | "38002" -> MODIFYING_SQL_DATA_NOT_PERMITTED
    | "38003" -> PROHIBITED_SQL_STATEMENT_ATTEMPTED
    | "38004" -> READING_SQL_DATA_NOT_PERMITTED
    | "39000" -> EXTERNAL_ROUTINE_INVOCATION_EXCEPTION
    | "39001" -> INVALID_SQLSTATE_RETURNED
    | "39004" -> NULL_VALUE_NOT_ALLOWED
    | "39P01" -> TRIGGER_PROTOCOL_VIOLATED
    | "39P02" -> SRF_PROTOCOL_VIOLATED
    | "39P03" -> EVENT_TRIGGER_PROTOCOL_VIOLATED
    | "3B000" -> SAVEPOINT_EXCEPTION
    | "3B001" -> INVALID_SAVEPOINT_SPECIFICATION
    | "3D000" -> INVALID_CATALOG_NAME
    | "3F000" -> INVALID_SCHEMA_NAME
    | "40000" -> TRANSACTION_ROLLBACK
    | "40002" -> TRANSACTION_INTEGRITY_CONSTRAINT_VIOLATION
    | "40001" -> SERIALIZATION_FAILURE
    | "40003" -> STATEMENT_COMPLETION_UNKNOWN
    | "40P01" -> DEADLOCK_DETECTED
    | "42000" -> SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION
    | "42601" -> SYNTAX_ERROR
    | "42501" -> INSUFFICIENT_PRIVILEGE
    | "42846" -> CANNOT_COERCE
    | "42803" -> GROUPING_ERROR
    | "42P20" -> WINDOWING_ERROR
    | "42P19" -> INVALID_RECURSION
    | "42830" -> INVALID_FOREIGN_KEY
    | "42602" -> INVALID_NAME
    | "42622" -> NAME_TOO_LONG
    | "42939" -> RESERVED_NAME
    | "42804" -> DATATYPE_MISMATCH
    | "42P18" -> INDETERMINATE_DATATYPE
    | "42P21" -> COLLATION_MISMATCH
    | "42P22" -> INDETERMINATE_COLLATION
    | "42809" -> WRONG_OBJECT_TYPE
    | "428C9" -> GENERATED_ALWAYS
    | "42703" -> UNDEFINED_COLUMN
    | "42883" -> UNDEFINED_FUNCTION
    | "42P01" -> UNDEFINED_TABLE
    | "42P02" -> UNDEFINED_PARAMETER
    | "42704" -> UNDEFINED_OBJECT
    | "42701" -> DUPLICATE_COLUMN
    | "42P03" -> DUPLICATE_CURSOR
    | "42P04" -> DUPLICATE_DATABASE
    | "42723" -> DUPLICATE_FUNCTION
    | "42P05" -> DUPLICATE_PREPARED_STATEMENT
    | "42P06" -> DUPLICATE_SCHEMA
    | "42P07" -> DUPLICATE_TABLE
    | "42712" -> DUPLICATE_ALIAS
    | "42710" -> DUPLICATE_OBJECT
    | "42702" -> AMBIGUOUS_COLUMN
    | "42725" -> AMBIGUOUS_FUNCTION
    | "42P08" -> AMBIGUOUS_PARAMETER
    | "42P09" -> AMBIGUOUS_ALIAS
    | "42P10" -> INVALID_COLUMN_REFERENCE
    | "42611" -> INVALID_COLUMN_DEFINITION
    | "42P11" -> INVALID_CURSOR_DEFINITION
    | "42P12" -> INVALID_DATABASE_DEFINITION
    | "42P13" -> INVALID_FUNCTION_DEFINITION
    | "42P14" -> INVALID_PREPARED_STATEMENT_DEFINITION
    | "42P15" -> INVALID_SCHEMA_DEFINITION
    | "42P16" -> INVALID_TABLE_DEFINITION
    | "42P17" -> INVALID_OBJECT_DEFINITION
    | "44000" -> WITH_CHECK_OPTION_VIOLATION
    | "53000" -> INSUFFICIENT_RESOURCES
    | "53100" -> DISK_FULL
    | "53200" -> OUT_OF_MEMORY
    | "53300" -> TOO_MANY_CONNECTIONS
    | "53400" -> CONFIGURATION_LIMIT_EXCEEDED
    | "54000" -> PROGRAM_LIMIT_EXCEEDED
    | "54001" -> STATEMENT_TOO_COMPLEX
    | "54011" -> TOO_MANY_COLUMNS
    | "54023" -> TOO_MANY_ARGUMENTS
    | "55000" -> OBJECT_NOT_IN_PREREQUISITE_STATE
    | "55006" -> OBJECT_IN_USE
    | "55P02" -> CANT_CHANGE_RUNTIME_PARAM
    | "55P03" -> LOCK_NOT_AVAILABLE
    | "57000" -> OPERATOR_INTERVENTION
    | "57014" -> QUERY_CANCELED
    | "57P01" -> ADMIN_SHUTDOWN
    | "57P02" -> CRASH_SHUTDOWN
    | "57P03" -> CANNOT_CONNECT_NOW
    | "57P04" -> DATABASE_DROPPED
    | "58000" -> SYSTEM_ERROR
    | "58030" -> IO_ERROR
    | "58P01" -> UNDEFINED_FILE
    | "58P02" -> DUPLICATE_FILE
    | "72000" -> SNAPSHOT_TOO_OLD
    | "F0000" -> CONFIG_FILE_ERROR
    | "F0001" -> LOCK_FILE_EXISTS
    | "HV000" -> FDW_ERROR
    | "HV005" -> FDW_COLUMN_NAME_NOT_FOUND
    | "HV002" -> FDW_DYNAMIC_PARAMETER_VALUE_NEEDED
    | "HV010" -> FDW_FUNCTION_SEQUENCE_ERROR
    | "HV021" -> FDW_INCONSISTENT_DESCRIPTOR_INFORMATION
    | "HV024" -> FDW_INVALID_ATTRIBUTE_VALUE
    | "HV007" -> FDW_INVALID_COLUMN_NAME
    | "HV008" -> FDW_INVALID_COLUMN_NUMBER
    | "HV004" -> FDW_INVALID_DATA_TYPE
    | "HV006" -> FDW_INVALID_DATA_TYPE_DESCRIPTORS
    | "HV091" -> FDW_INVALID_DESCRIPTOR_FIELD_IDENTIFIER
    | "HV00B" -> FDW_INVALID_HANDLE
    | "HV00C" -> FDW_INVALID_OPTION_INDEX
    | "HV00D" -> FDW_INVALID_OPTION_NAME
    | "HV090" -> FDW_INVALID_STRING_LENGTH_OR_BUFFER_LENGTH
    | "HV00A" -> FDW_INVALID_STRING_FORMAT
    | "HV009" -> FDW_INVALID_USE_OF_NULL_POINTER
    | "HV014" -> FDW_TOO_MANY_HANDLES
    | "HV001" -> FDW_OUT_OF_MEMORY
    | "HV00P" -> FDW_NO_SCHEMAS
    | "HV00J" -> FDW_OPTION_NAME_NOT_FOUND
    | "HV00K" -> FDW_REPLY_HANDLE
    | "HV00Q" -> FDW_SCHEMA_NOT_FOUND
    | "HV00R" -> FDW_TABLE_NOT_FOUND
    | "HV00L" -> FDW_UNABLE_TO_CREATE_EXECUTION
    | "HV00M" -> FDW_UNABLE_TO_CREATE_REPLY
    | "HV00N" -> FDW_UNABLE_TO_ESTABLISH_CONNECTION
    | "P0000" -> PLPGSQL_ERROR
    | "P0001" -> RAISE_EXCEPTION
    | "P0002" -> NO_DATA_FOUND
    | "P0003" -> TOO_MANY_ROWS
    | "P0004" -> ASSERT_FAILURE
    | "XX000" -> INTERNAL_ERROR
    | "XX001" -> DATA_CORRUPTED
    | "XX002" -> INDEX_CORRUPTED
    | _ -> raise (Failure ("Unknown error code " ^ error_code))
end

external error_field_name_of_error_field_id : (error_id [@untagged]) -> Error_field_name.t
  = "error_field_name_of_error_field_id_stub_bc" "error_field_name_of_error_field_id_stub"

external error_field_id_of_error_field_name : Error_field_name.t -> (error_id [@untagged])
  = "error_field_id_of_error_field_name_stub_bc" "error_field_id_of_error_field_name_stub" [@@noalloc]

module FFormat = struct
  type t =
    | TEXT
    | BINARY
end

type ftype =
  | BOOL
  | BYTEA
  | CHAR
  | NAME
  | INT8
  | INT2
  | INT2VECTOR
  | INT4
  | REGPROC
  | TEXT
  | OID
  | TID
  | XID
  | CID
  | OIDVECTOR
  | JSON
  | POINT
  | LSEG
  | PATH
  | BOX
  | POLYGON
  | LINE
  | FLOAT4
  | FLOAT8
  | ABSTIME
  | RELTIME
  | TINTERVAL
  | UNKNOWN
  | CIRCLE
  | CASH
  | MACADDR
  | INET
  | CIDR
  | ACLITEM
  | BPCHAR
  | VARCHAR
  | DATE
  | TIME
  | TIMESTAMP
  | TIMESTAMPTZ
  | INTERVAL
  | TIMETZ
  | BIT
  | VARBIT
  | NUMERIC
  | REFCURSOR
  | REGPROCEDURE
  | REGOPER
  | REGOPERATOR
  | REGCLASS
  | REGTYPE
  | RECORD
  | CSTRING
  | ANY
  | ANYARRAY
  | VOID
  | TRIGGER
  | LANGUAGE_HANDLER
  | INTERNAL
  | OPAQUE
  | ANYELEMENT
  | JSONB

external ftype_of_oid : (oid [@untagged]) -> ftype
  = "ftype_of_oid_stub_bc" "ftype_of_oid_stub"

external oid_of_ftype : ftype -> (oid [@untagged])
  = "oid_of_ftype_stub_bc" "oid_of_ftype_stub" [@@noalloc]

let string_of_ftype = function
  | BOOL -> "BOOL"
  | BYTEA -> "BYTEA"
  | CHAR -> "CHAR"
  | NAME -> "NAME"
  | INT8 -> "INT8"
  | INT2 -> "INT2"
  | INT2VECTOR -> "INT2VECTOR"
  | INT4 -> "INT4"
  | REGPROC -> "REGPROC"
  | TEXT -> "TEXT"
  | OID -> "OID"
  | TID -> "TID"
  | XID -> "XID"
  | CID -> "CID"
  | OIDVECTOR -> "OIDVECTOR"
  | JSON -> "JSON"
  | POINT -> "POINT"
  | LSEG -> "LSEG"
  | PATH -> "PATH"
  | BOX -> "BOX"
  | POLYGON -> "POLYGON"
  | LINE -> "LINE"
  | FLOAT4 -> "FLOAT4"
  | FLOAT8 -> "FLOAT8"
  | ABSTIME -> "ABSTIME"
  | RELTIME -> "RELTIME"
  | TINTERVAL -> "TINTERVAL"
  | UNKNOWN -> "UNKNOWN"
  | CIRCLE -> "CIRCLE"
  | CASH -> "CASH"
  | MACADDR -> "MACADDR"
  | INET -> "INET"
  | CIDR -> "CIDR"
  | ACLITEM -> "ACLITEM"
  | BPCHAR -> "BPCHAR"
  | VARCHAR -> "VARCHAR"
  | DATE -> "DATE"
  | TIME -> "TIME"
  | TIMESTAMP -> "TIMESTAMP"
  | TIMESTAMPTZ -> "TIMESTAMPTZ"
  | INTERVAL -> "INTERVAL"
  | TIMETZ -> "TIMETZ"
  | BIT -> "BIT"
  | VARBIT -> "VARBIT"
  | NUMERIC -> "NUMERIC"
  | REFCURSOR -> "REFCURSOR"
  | REGPROCEDURE -> "REGPROCEDURE"
  | REGOPER -> "REGOPER"
  | REGOPERATOR -> "REGOPERATOR"
  | REGCLASS -> "REGCLASS"
  | REGTYPE -> "REGTYPE"
  | RECORD -> "RECORD"
  | CSTRING -> "CSTRING"
  | ANY -> "ANY"
  | ANYARRAY -> "ANYARRAY"
  | VOID -> "VOID"
  | TRIGGER -> "TRIGGER"
  | LANGUAGE_HANDLER -> "LANGUAGE_HANDLER"
  | INTERNAL -> "INTERNAL"
  | OPAQUE -> "OPAQUE"
  | ANYELEMENT -> "ANYELEMENT"
  | JSONB -> "JSONB"

let ftype_of_string = function
  | "BOOL" -> BOOL
  | "BYTEA" -> BYTEA
  | "CHAR" -> CHAR
  | "NAME" -> NAME
  | "INT8" -> INT8
  | "INT2" -> INT2
  | "INT2VECTOR" -> INT2VECTOR
  | "INT4" -> INT4
  | "REGPROC" -> REGPROC
  | "TEXT" -> TEXT
  | "OID" -> OID
  | "TID" -> TID
  | "XID" -> XID
  | "CID" -> CID
  | "OIDVECTOR" -> OIDVECTOR
  | "JSON" -> JSON
  | "POINT" -> POINT
  | "LSEG" -> LSEG
  | "PATH" -> PATH
  | "BOX" -> BOX
  | "POLYGON" -> POLYGON
  | "LINE" -> LINE
  | "FLOAT4" -> FLOAT4
  | "FLOAT8" -> FLOAT8
  | "ABSTIME" -> ABSTIME
  | "RELTIME" -> RELTIME
  | "TINTERVAL" -> TINTERVAL
  | "UNKNOWN" -> UNKNOWN
  | "CIRCLE" -> CIRCLE
  | "CASH" -> CASH
  | "MACADDR" -> MACADDR
  | "INET" -> INET
  | "CIDR" -> CIDR
  | "ACLITEM" -> ACLITEM
  | "BPCHAR" -> BPCHAR
  | "VARCHAR" -> VARCHAR
  | "DATE" -> DATE
  | "TIME" -> TIME
  | "TIMESTAMP" -> TIMESTAMP
  | "TIMESTAMPTZ" -> TIMESTAMPTZ
  | "INTERVAL" -> INTERVAL
  | "TIMETZ" -> TIMETZ
  | "BIT" -> BIT
  | "VARBIT" -> VARBIT
  | "NUMERIC" -> NUMERIC
  | "REFCURSOR" -> REFCURSOR
  | "REGPROCEDURE" -> REGPROCEDURE
  | "REGOPER" -> REGOPER
  | "REGOPERATOR" -> REGOPERATOR
  | "REGCLASS" -> REGCLASS
  | "REGTYPE" -> REGTYPE
  | "RECORD" -> RECORD
  | "CSTRING" -> CSTRING
  | "ANY" -> ANY
  | "ANYARRAY" -> ANYARRAY
  | "VOID" -> VOID
  | "TRIGGER" -> TRIGGER
  | "LANGUAGE_HANDLER" -> LANGUAGE_HANDLER
  | "INTERNAL" -> INTERNAL
  | "OPAQUE" -> OPAQUE
  | "ANYELEMENT" -> ANYELEMENT
  | "JSONB" -> JSONB
  | str -> failwith ("ftype_of_string: unknown ftype: " ^ str)

external init : unit -> unit = "PQocaml_init"

let null = ""

let () =
  Callback.register_exception "Postgresql.Oid" (Oid invalid_oid);
  Callback.register "Postgresql.null" null;
  init ()

type connection_status =
  | Ok | Bad
  | Connection_started
  | Connection_made
  | Connection_awaiting_response
  | Connection_auth_ok
  | Connection_setenv
  | Connection_ssl_startup

type polling_status =
  | Polling_failed
  | Polling_reading
  | Polling_writing
  | Polling_ok

type flush_status =
  | Successful
  | Data_left_to_send

type conninfo_option =
  {
    cio_keyword : string;
    cio_envvar : string option;
    cio_compiled : string option;
    cio_val : string option;
    cio_label : string;
    cio_dispchar : string;
    cio_dispsize : int;
  }

type result_status =
  | Empty_query
  | Command_ok
  | Tuples_ok
  | Copy_out
  | Copy_in
  | Bad_response
  | Nonfatal_error
  | Fatal_error
  | Copy_both
  | Single_tuple

external result_status : result_status -> string = "PQresStatus_stub"

type getline_result = EOF | LineRead | BufFull

type getline_async_result =
  | EndOfData
  | NoData
  | DataRead of int
  | PartDataRead of int

type seek_cmd =
  | SEEK_SET
  | SEEK_CUR
  | SEEK_END

type error =
  | Field_out_of_range of int * int
  | Tuple_out_of_range of int * int
  | Binary
  | Connection_failure of string
  | Unexpected_status of result_status * string * (result_status list)
  | Cancel_failure of string

let string_of_error = function
  | Field_out_of_range (i, n) ->
      sprintf "Field number %i is out of range [0..%i]" i (n - 1)
  | Tuple_out_of_range (i, n) ->
      sprintf "Tuple number %i is out of range [0..%i]" i (n - 1)
  | Binary -> sprintf "This function does not accept binary tuples"
  | Connection_failure s -> "Connection failure: " ^ s
  | Unexpected_status (s, msg, sl) ->
      sprintf "Result status %s unexpected (expected status:%s); %s"
        (result_status s) (String.concat "," (List.map result_status sl))
        msg
  | Cancel_failure s -> "Cancel failure: " ^ s

exception Error of error

module Notification = struct
  type t = { name : string; pid : int; extra : string }
end  (* Notification *)

module Stub = struct
  (* Database Connection Functions *)

  type connection
  type result

  external conn_isnull : connection -> bool = "PQconn_isnull" [@@noalloc]
  external connect : string -> bool -> connection = "PQconnectdb_stub"
  external finish : connection -> unit = "PQfinish_stub"
  external reset : connection -> unit = "PQreset_stub"

  external db : connection -> string = "PQdb_stub"
  external user : connection -> string = "PQuser_stub"
  external pass : connection -> string = "PQpass_stub"
  external host : connection -> string = "PQhost_stub"
  external port : connection -> string = "PQport_stub"
  external tty : connection -> string = "PQtty_stub"
  external options : connection -> string = "PQoptions_stub"

  external connection_status :
    connection -> connection_status = "PQstatus_stub" [@@noalloc]

  external error_message : connection -> string = "PQerrorMessage_stub"

  external backend_pid : connection -> (int [@untagged])
    = "PQbackendPID_stub_bc" "PQbackendPID_stub" [@@noalloc]

  external server_version : connection -> (int [@untagged])
    = "PQserverVersion_stub_bc" "PQserverVersion_stub" [@@noalloc]

  (* Command Execution Functions *)

  external result_isnull : result -> bool = "PQres_isnull" [@@noalloc]

  external exec_params :
    connection -> string -> string array -> bool array -> result
    = "PQexecParams_stub"

  external prepare : connection -> string -> string -> result = "PQprepare_stub"

  external exec_prepared :
    connection -> string -> string array -> bool array -> result
    = "PQexecPrepared_stub"

  external describe_prepared :
    connection -> string -> result = "PQdescribePrepared_stub"

  external result_status :
    result -> result_status = "PQresultStatus_stub" [@@noalloc]

  external result_error : result -> string = "PQresultErrorMessage_stub"

  external result_error_field : result -> error_id -> string = "PQresultErrorField_stub"

  external make_empty_res :
    connection -> result_status -> result = "PQmakeEmptyPGresult_stub"

  external ntuples : result -> (int [@untagged])
    = "PQntuples_stub_bc" "PQntuples_stub" [@@noalloc]

  external nparams : result -> (int [@untagged])
    = "PQnparams_stub_bc" "PQnparams_stub"

  external nfields : result -> (int [@untagged])
    = "PQnfields_stub_bc" "PQnfields_stub" [@@noalloc]

  external fname : result -> (int [@untagged]) -> string
    = "PQfname_stub_bc" "PQfname_stub"

  external fnumber : result -> string -> (int [@untagged])
    = "PQfnumber_stub_bc" "PQfnumber_stub" [@@noalloc]

  external fformat : result -> (int [@untagged]) -> FFormat.t
    = "PQfformat_stub_bc" "PQfformat_stub" [@@noalloc]

  external ftype : result -> (int [@untagged]) -> (oid [@untagged])
    = "PQftype_stub_bc" "PQftype_stub" [@@noalloc]

  external paramtype : result -> (int [@untagged]) -> (oid [@untagged])
    = "PQparamtype_stub_bc" "PQparamtype_stub"

  external fmod : result -> (int [@untagged]) -> (int [@untagged])
    = "PQfmod_stub_bc" "PQfmod_stub" [@@noalloc]

  external fsize : result -> (int [@untagged]) -> (int [@untagged])
    = "PQfsize_stub_bc" "PQfsize_stub" [@@noalloc]

  external binary_tuples : result -> bool = "PQbinaryTuples_stub" [@@noalloc]

  external getvalue : result -> (int [@untagged]) -> (int [@untagged]) -> string
    = "PQgetvalue_stub_bc" "PQgetvalue_stub"

  external get_escaped_value :
    result -> (int [@untagged]) -> (int [@untagged]) -> string
    = "PQgetescval_stub_bc" "PQgetescval_stub"

  external getisnull : result -> (int [@untagged]) -> (int [@untagged]) -> bool
    = "PQgetisnull_stub_bc" "PQgetisnull_stub" [@@noalloc]

  external getlength :
    result -> (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "PQgetlength_stub_bc" "PQgetlength_stub" [@@noalloc]

  external cmd_status : result -> string = "PQcmdStatus_stub"
  external cmd_tuples : result -> string = "PQcmdTuples_stub"

  external oid_value : result -> (oid [@untagged])
    = "PQoidValue_stub_bc" "PQoidValue_stub" [@@noalloc]


  (* Asynchronous Query Processing *)

  external connect_poll :
    connection -> polling_status = "PQconnectPoll_stub" [@@noalloc]

  external reset_start : connection -> bool = "PQresetStart_stub" [@@noalloc]

  external reset_poll :
    connection -> polling_status = "PQresetPoll_stub" [@@noalloc]

  external set_nonblocking : connection -> bool -> (int [@untagged])
    = "PQsetnonblocking_stub_bc" "PQsetnonblocking_stub" [@@noalloc]

  external is_nonblocking :
    connection -> bool = "PQisnonblocking_stub" [@@noalloc]

  external send_query_params :
    connection -> string -> string array -> bool array -> (int [@untagged])
    = "PQsendQueryParams_stub_bc" "PQsendQueryParams_stub"

  external send_prepare :
    connection -> string -> string -> (int [@untagged])
    = "PQsendPrepare_stub_bc" "PQsendPrepare_stub" [@@noalloc]

  external send_query_prepared :
    connection -> string -> string array -> bool array -> (int [@untagged])
    = "PQsendQueryPrepared_stub_bc" "PQsendQueryPrepared_stub"

  external send_describe_prepared : connection -> string -> (int [@untagged])
    = "PQsendDescribePrepared_stub_bc" "PQsendDescribePrepared_stub"

  external send_describe_portal : connection -> string -> (int [@untagged])
    = "PQsendDescribePortal_stub_bc" "PQsendDescribePortal_stub"

  external set_single_row_mode : connection -> (int [@untagged])
    = "PQsetSingleRowMode_stub_bc" "PQsetSingleRowMode_stub"

  external get_result : connection -> result = "PQgetResult_stub"

  external consume_input : connection -> (int [@untagged])
    = "PQconsumeInput_stub_bc" "PQconsumeInput_stub" [@@noalloc]

  external is_busy : connection -> bool = "PQisBusy_stub" [@@noalloc]

  external flush : connection -> (int [@untagged])
    = "PQflush_stub_bc" "PQflush_stub" [@@noalloc]

  external socket : connection -> (int [@untagged])
    = "PQsocket_stub_bc" "PQsocket_stub" [@@noalloc]

  external request_cancel : connection -> string option = "PQCancel_stub"


  (* Asynchronous Notification *)

  external notifies : connection -> Notification.t option = "PQnotifies_stub"


  (* Functions Associated with the COPY Command *)

  external getline :
    connection -> Bytes.t ->
    (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "PQgetline_stub_bc" "PQgetline_stub"

  external getline_async :
    connection -> Bytes.t ->
    (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "PQgetlineAsync_stub_bc" "PQgetlineAsync_stub" [@@noalloc]

  external putline : connection -> string -> (int [@untagged])
    = "PQputline_stub_bc" "PQputline_stub"

  external putnbytes :
    connection -> string ->
    (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "PQputnbytes_stub_bc" "PQputnbytes_stub"

  external endcopy : connection -> (int [@untagged])
    = "PQendcopy_stub_bc" "PQendcopy_stub"

  external escape_string_conn :
    connection -> string ->
    pos : (int [@untagged]) -> len : (int [@untagged]) -> string
    = "PQescapeStringConn_stub_bc" "PQescapeStringConn_stub"

  external escape_bytea_conn :
    connection -> string ->
    pos : (int [@untagged]) -> len : (int [@untagged]) -> string
    = "PQescapeByteaConn_stub_bc" "PQescapeByteaConn_stub"


  (* Control Functions *)

  external set_notice_processor :
    connection -> (string -> unit) -> unit = "PQsetNoticeProcessor_stub"


  (* Large objects *)

  external lo_creat : connection -> (oid [@untagged])
    = "lo_creat_stub_bc" "lo_creat_stub"

  external lo_import : connection -> string -> (oid [@untagged])
    = "lo_import_stub_bc" "lo_import_stub"

  external lo_export :
    connection -> (oid [@untagged]) -> string -> (int [@untagged])
    = "lo_export_stub_bc" "lo_export_stub"

  external lo_open :
    connection -> (oid [@untagged]) -> (large_object [@untagged])
    = "lo_open_stub_bc" "lo_open_stub"

  external lo_close :
    connection -> (large_object [@untagged]) -> (int [@untagged])
    = "lo_close_stub_bc" "lo_close_stub"

  external lo_tell :
    connection -> (large_object [@untagged]) -> (int [@untagged])
    = "lo_tell_stub_bc" "lo_tell_stub"

  external lo_unlink : connection -> (oid [@untagged]) -> (oid [@untagged])
    = "lo_unlink_stub_bc" "lo_unlink_stub"

  external lo_read :
    connection -> (large_object [@untagged]) ->
    Bytes.t -> (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "lo_read_stub_bc" "lo_read_stub"

  external lo_read_ba :
    connection -> (large_object [@untagged]) ->
    (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t ->
    (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "lo_read_ba_stub_bc" "lo_read_ba_stub"

  external lo_write :
    connection -> (large_object [@untagged]) ->
    string -> (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "lo_write_stub_bc" "lo_write_stub"

  external lo_write_ba :
    connection -> (large_object [@untagged]) ->
    (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t ->
    (int [@untagged]) -> (int [@untagged]) -> (int [@untagged])
    = "lo_write_ba_stub_bc" "lo_write_ba_stub"

  external lo_seek :
    connection -> (large_object [@untagged]) ->
    (int [@untagged]) -> seek_cmd -> (int [@untagged])
    = "lo_lseek_stub_bc" "lo_lseek_stub"
end


(* Escaping *)

external unescape_bytea : string -> string = "PQunescapeBytea_stub"


(* Query results *)

class result res =
  let nfields = Stub.nfields res in
  let ntuples = Stub.ntuples res in
  let nparams = lazy (Stub.nparams res) in
  let check_field field =
    if field < 0 || field >= nfields then
      raise (Error (Field_out_of_range (field, nfields))) in
  let check_param param =
    let nparams = Lazy.force nparams in
    if param < 0 || param >= nparams then
      raise (Error (Field_out_of_range (param, nparams))) in
  let check_tuple tuple =
    if tuple < 0 || tuple >= ntuples then
      raise (Error (Tuple_out_of_range (tuple, ntuples))) in
object
  method status = Stub.result_status res
  method error = Stub.result_error res
  method error_field field_name : string =
    let field = error_field_id_of_error_field_name field_name in
    Stub.result_error_field res field
  method error_field_condition_name =
    let field = error_field_id_of_error_field_name Error_field_name.(PG_DIAG_SQLSTATE) in
    let error_code = Stub.result_error_field res field in
    Error_code.condition_name_of_error_code error_code
  method ntuples = ntuples
  method nparams = Lazy.force nparams
  method nfields = nfields
  method binary_tuples = Stub.binary_tuples res
  method fname field = check_field field; Stub.fname res field

  method fnumber s =
    let n = Stub.fnumber res s in
    if n = -1 then raise Not_found else n

  method fformat field =
    check_field field;
    Stub.fformat res field

  method ftype field =
    check_field field;
    ftype_of_oid (Stub.ftype res field)

  method ftype_oid field =
    check_field field;
    Stub.ftype res field

  method paramtype field =
    check_param field;
    ftype_of_oid (Stub.paramtype res field)

  method paramtype_oid field =
    check_param field;
    Stub.paramtype res field

  method fmod field = check_field field; Stub.fmod res field
  method fsize field = check_field field; Stub.fsize res field

  method getvalue tuple field =
    check_field field;
    check_tuple tuple;
    Stub.getvalue res tuple field

  method get_escaped_value tuple field =
    check_field field;
    check_tuple tuple;
    Stub.get_escaped_value res tuple field

  method getisnull tuple field =
    check_field field; check_tuple tuple;
    Stub.getisnull res tuple field

  method getlength tuple field =
    check_field field; check_tuple tuple;
    Stub.getlength res tuple field

  method cmd_status = Stub.cmd_status res
  method cmd_tuples = Stub.cmd_tuples res
  method oid_value = Stub.oid_value res

  method get_fnames = Array.init nfields (Stub.fname res)

  method get_fnames_lst =
    let lst_ref = ref [] in
    for i = nfields - 1 downto 0 do
      lst_ref := Stub.fname res i :: !lst_ref;
    done;
    !lst_ref

  method get_tuple t = check_tuple t; Array.init nfields (Stub.getvalue res t)

  method get_tuple_lst t =
    check_tuple t;
    let tpl_ref = ref [] in
    for i = nfields - 1 downto 0 do
      tpl_ref := Stub.getvalue res t i :: !tpl_ref;
    done;
    !tpl_ref

  method get_all =
    Array.init ntuples (fun t -> Array.init nfields (Stub.getvalue res t))

  method get_all_lst =
    let lst_ref = ref [] in
    let nfields_1 = nfields - 1 in
    for t = ntuples - 1 downto 0 do
      let tpl_ref = ref [] in
      for i = nfields_1 downto 0 do
        tpl_ref := Stub.getvalue res t i :: !tpl_ref
      done;
      lst_ref := !tpl_ref :: !lst_ref
    done;
    !lst_ref
end


(* Connections *)

external conndefaults : unit -> conninfo_option array = "PQconndefaults_stub"

exception Finally of exn * exn

let protectx ~f x ~(finally : 'a -> unit) =
  let res =
    try f x
    with exn ->
      (try finally x with final_exn -> raise (Finally (exn, final_exn)));
      raise exn
  in
  finally x;
  res

class connection ?host ?hostaddr ?port ?dbname ?user ?password ?options ?tty
    ?requiressl ?conninfo ?(startonly = false) =

  let conn_info =
    match conninfo with
    | Some conn_info -> conn_info
    | None ->
        let b = Buffer.create 512 in
        let field name = function
          | None -> ()
          | Some x ->
              Printf.bprintf b "%s='" name;
              for i = 0 to String.length x - 1 do
                if x.[i]='\''
                then Buffer.add_string b "\\'"
                else Buffer.add_char b x.[i]
              done;
              Buffer.add_string b "' " in
        field "host" host;
        field "hostaddr" hostaddr;
        field "port" port;
        field "dbname" dbname;
        field "user" user;
        field "password" password;
        field "options" options;
        field "tty" tty;
        field "requiressl" requiressl;
        Buffer.contents b in

  fun () ->
    let my_conn = Stub.connect conn_info startonly in
    let () =
      if Stub.connection_status my_conn = Bad then (
        let s = Stub.error_message my_conn in
        Stub.finish my_conn;
        raise (Error (Connection_failure s)))
      else Gc.finalise Stub.finish my_conn
    in
    let conn_mtx = Mutex.create () in
    let conn_cnd = Condition.create () in
    let conn_state = ref `Free in
    let check_null () =
      if Stub.conn_isnull my_conn then
        failwith "Postgresql.check_null: connection already finished"
    in
    let wrap_mtx f =
      Mutex.lock conn_mtx;
      protectx conn_mtx
        ~f:(fun _ ->
          check_null ();  (* Check now to avoid blocking *)
          f ())
        ~finally:Mutex.unlock
    in
    let wrap_conn ?(state = `Used) f =
      wrap_mtx (fun () ->
        while !conn_state <> `Free do Condition.wait conn_cnd conn_mtx done;
        conn_state := state);
      protectx conn_state
        ~f:(fun _ ->
          check_null ();  (* Check again in case the world has changed *)
          f my_conn)
        ~finally:(fun _ ->
          Mutex.lock conn_mtx;
          conn_state := `Free;
          Condition.signal conn_cnd;
          Mutex.unlock conn_mtx)
    in
    let signal_error conn =
      raise (Error (Connection_failure (Stub.error_message conn)))
    in
    let request_cancel () =
      wrap_mtx (fun _ ->
        match !conn_state with
        | `Finishing | `Free -> ()
        | `Used ->
            match Stub.request_cancel my_conn with
            | None -> ()
            | Some err -> raise (Error (Cancel_failure err)))
    in
    let get_str_pos_len ~loc ?pos ?len str =
      let str_len = String.length str in
      match pos, len with
      | None, None -> 0, str_len
      | Some pos, _ when pos < 0 ->
          invalid_arg (sprintf "Postgresql.%s: pos < 0" loc)
      | _, Some len when len < 0 ->
          invalid_arg (sprintf "Postgresql.%s: len < 0" loc)
      | Some pos, None when pos > str_len ->
          invalid_arg (sprintf "Postgresql.%s: pos > length(str)" loc)
      | Some pos, None -> pos, str_len - pos
      | None, Some len when len > str_len ->
          invalid_arg (sprintf "Postgresql.%s: len > length(str)" loc)
      | None, Some len -> 0, len
      | Some pos, Some len when pos + len > str_len ->
          invalid_arg (sprintf "Postgresql.%s: pos + len > length(str)" loc)
      | Some pos, Some len -> pos, len
    in

object (self)
  (* Main routines *)

  method finish = wrap_conn ~state:`Finishing Stub.finish

  method try_reset =
    wrap_conn (fun conn ->
    if Stub.connection_status conn = Bad then (
      Stub.reset conn;
      if Stub.connection_status conn <> Ok then signal_error conn))

  method reset = wrap_conn Stub.reset


  (* Asynchronous Notification *)

  method notifies = wrap_conn Stub.notifies


  (* Control Functions *)

  method set_notice_processor f =
    wrap_conn (fun conn -> Stub.set_notice_processor conn f)


  (* Accessors *)

  method db = wrap_conn Stub.db
  method user = wrap_conn Stub.user
  method pass = wrap_conn Stub.pass
  method host = wrap_conn Stub.host
  method port = wrap_conn Stub.port
  method tty = wrap_conn Stub.tty
  method options = wrap_conn Stub.options
  method status = wrap_conn Stub.connection_status
  method error_message = wrap_conn Stub.error_message
  method backend_pid = wrap_conn Stub.backend_pid

  method server_version =
    let version =
      wrap_conn (fun conn ->
        let version = Stub.server_version conn in
        if version <> 0 then version
        else
          let msg =
            if Stub.connection_status conn = Bad
            then "server_version failed because the connection was bad"
            else "server_version failed for an unknown reason"
          in
          raise (Error (Connection_failure msg)))
    in
    let major = version / (100 * 100) in
    let minor = (version / 100) mod 100 in
    let revision = version mod 100 in
    major, minor, revision


  (* Commands and Queries *)

  method empty_result status =
    new result (wrap_conn (fun conn -> (Stub.make_empty_res conn status)))

  method exec ?(expect = []) ?(params = [||]) ?(binary_params = [||]) query =
    let r =
      wrap_conn (fun conn ->
        let r = Stub.exec_params conn query params binary_params in
        if Stub.result_isnull r then signal_error conn
        else r)
    in
    let res = new result r in
    let stat = res#status in
    if not (expect = []) && not (List.mem stat expect) then
      raise (Error (Unexpected_status (stat, res#error, expect)))
    else res

  method prepare stm_name query =
    new result (
      wrap_conn (fun conn ->
        let r = Stub.prepare conn stm_name query in
        if Stub.result_isnull r then signal_error conn
        else r))

  method exec_prepared
    ?(expect = []) ?(params = [||]) ?(binary_params = [||]) stm_name =
    let r =
      wrap_conn (fun conn ->
        let r = Stub.exec_prepared conn stm_name params binary_params in
        if Stub.result_isnull r then signal_error conn
        else r)
    in
    let res = new result r in
    let stat = res#status in
    if not (expect = []) && not (List.mem stat expect) then
      raise (Error (Unexpected_status (stat, res#error, expect)))
    else res

  method describe_prepared query =
    new result (
      wrap_conn (fun conn ->
        let r = Stub.describe_prepared conn query in
        if Stub.result_isnull r then signal_error conn
        else r))

  method send_query ?(params = [||]) ?(binary_params = [||]) query =
    wrap_conn (fun conn ->
      if Stub.send_query_params conn query params binary_params <> 1 then
        signal_error conn)

  method send_prepare stm_name query =
    wrap_conn (fun conn ->
      if Stub.send_prepare conn stm_name query <> 1 then signal_error conn)

  method send_query_prepared ?(params = [||]) ?(binary_params = [||]) stm_name =
    wrap_conn (fun conn ->
      if Stub.send_query_prepared conn stm_name params binary_params <> 1 then
        signal_error conn)

  method send_describe_prepared stm_name =
    wrap_conn (fun conn ->
      if Stub.send_describe_prepared conn stm_name <> 1 then signal_error conn)

  method send_describe_portal portal_name =
    wrap_conn (fun conn ->
      if Stub.send_describe_portal conn portal_name <> 1 then signal_error conn)

  method set_single_row_mode =
    wrap_conn (fun conn ->
      if Stub.set_single_row_mode conn <> 1 then signal_error conn)

  method get_result =
    let res = wrap_conn Stub.get_result in
    if Stub.result_isnull res then None else Some (new result res)


  (* Copy operations *)

  (* Low level *)

  method getline ?(pos = 0) ?len buf =
    let buf_len = Bytes.length buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#getline";
    wrap_conn (fun conn ->
      match Stub.getline conn buf pos len with
      | -1 -> EOF
      | 0 -> LineRead
      | 1 -> BufFull
      | _ -> assert false)

  method getline_async ?(pos = 0) ?len buf =
    let buf_len = Bytes.length buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#getline_async";
    wrap_conn (fun conn ->
      match Stub.getline_async conn buf pos len with
      | -1 -> if Stub.endcopy conn <> 0 then signal_error conn else EndOfData
      | 0 -> NoData
      | n when n > 0 ->
         if Bytes.get buf (pos + n - 1) = '\n' then DataRead n
         else PartDataRead n
      | _ -> assert false)

  method putline buf =
    wrap_conn (fun conn ->
      if Stub.putline conn buf <> 0 && not (Stub.is_nonblocking conn) then
        signal_error conn)

  method putnbytes ?(pos = 0) ?len buf =
    let buf_len = String.length buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#putnbytes";
    wrap_conn (fun conn ->
      if Stub.putnbytes conn buf pos len <> 0 && not (Stub.is_nonblocking conn)
      then signal_error conn)

  method endcopy =
    wrap_conn (fun conn ->
      if Stub.endcopy conn <> 0 && not (Stub.is_nonblocking conn) then
        signal_error conn)


  (* High level *)

  method copy_out f =
    let buf = Buffer.create 1024 in
    let len = 512 in
    let bts = Bytes.create len in
    wrap_conn (fun conn ->
      let rec loop () =
        let r = Stub.getline conn bts 0 len in
        if r = 1 then begin  (* Buffer full *)
          Buffer.add_subbytes buf bts 0 len;
          loop ()
        end
        else if r = 0 then  (* Line read *)
          let zero = Bytes.index bts '\000' in
          Buffer.add_subbytes buf bts 0 zero;
          match Buffer.contents buf with
          | "\\." -> ()
          | line -> Buffer.clear buf; f line; loop ()
        else if r = -1 then raise End_of_file
        else assert false  (* impossible *)
      in
      loop ());
    self#endcopy

  method copy_out_channel oc =
    self#copy_out (fun s -> output_string oc (s ^ "\n"))

  method copy_in_channel ic =
    try while true do self#putline (input_line ic ^ "\n") done;
    with End_of_file -> self#putline "\\.\n"; self#endcopy


  (* Asynchronous operations and non blocking mode *)

  method connect_poll = wrap_conn Stub.connect_poll
  method reset_start = wrap_conn Stub.reset_start
  method reset_poll = wrap_conn Stub.reset_poll

  method set_nonblocking b =
    wrap_conn (fun conn ->
      if Stub.set_nonblocking conn b <> 0 then signal_error conn)

  method is_nonblocking = wrap_conn Stub.is_nonblocking

  method consume_input =
    wrap_conn (fun conn ->
      if Stub.consume_input conn <> 1 then signal_error conn)

  method is_busy = wrap_conn Stub.is_busy

  method flush =
    wrap_conn (fun conn ->
      match Stub.flush conn with
      | 0 -> Successful
      | 1 -> Data_left_to_send
      | _ -> signal_error conn)

  method socket =
    wrap_conn (fun conn ->
      let s = Stub.socket conn in
      if s = -1 then signal_error conn else s)

  method request_cancel = request_cancel ()


  (* Large objects *)

  method lo_creat =
    wrap_conn (fun conn ->
      let lo = Stub.lo_creat conn in
      if lo <= 0 then signal_error conn;
      lo)

  method lo_import filename =
    wrap_conn (fun conn ->
      let oid = Stub.lo_import conn filename in
      if oid = 0 then signal_error conn;
      oid)

  method lo_export oid filename =
    wrap_conn (fun conn ->
      if Stub.lo_export conn oid filename <= 0 then signal_error conn)

  method lo_open oid =
    wrap_conn (fun conn ->
      let lo = Stub.lo_open conn oid in
      if lo = -1 then signal_error conn;
      lo)

  method lo_write ?(pos = 0) ?len buf lo =
    let buf_len = String.length buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > String.length buf then
      invalid_arg "Postgresql.connection#lo_write";
    wrap_conn (fun conn ->
      let w = Stub.lo_write conn lo buf pos len in
      if w < len then signal_error conn)

  method lo_write_ba ?(pos = 0) ?len buf lo =
    let buf_len = Bigarray.Array1.dim buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#lo_write_ba";
    wrap_conn (fun conn ->
      let w = Stub.lo_write_ba conn lo buf pos len in
      if w < len then signal_error conn)

  method lo_read lo ?(pos = 0) ?len buf =
    let buf_len = Bytes.length buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#lo_read";
    wrap_conn (fun conn ->
      let read = Stub.lo_read conn lo buf pos len in
      if read = -1 then signal_error conn;
      read)

  method lo_read_ba lo ?(pos = 0) ?len buf =
    let buf_len = Bigarray.Array1.dim buf in
    let len = match len with Some len -> len | None -> buf_len - pos in
    if len < 0 || pos < 0 || pos + len > buf_len then
      invalid_arg "Postgresql.connection#lo_read_ba";
    wrap_conn (fun conn ->
      let read = Stub.lo_read_ba conn lo buf pos len in
      if read = -1 then signal_error conn;
      read)

  method lo_seek ?(pos = 0) ?(whence = SEEK_SET) lo =
    wrap_conn (fun conn ->
      if Stub.lo_seek conn lo pos whence < 0 then signal_error conn)

  method lo_tell lo =
    wrap_conn (fun conn ->
      let pos = Stub.lo_tell conn lo in
      if pos = -1 then signal_error conn;
      pos)

  method lo_close oid =
    wrap_conn (fun conn ->
      if Stub.lo_close conn oid = -1 then signal_error conn)

  method lo_unlink oid =
    wrap_conn (fun conn ->
      let oid = Stub.lo_unlink conn oid in
      if oid = -1 then signal_error conn)


  (* Escaping *)

  method escape_string ?pos ?len str =
    let pos, len = get_str_pos_len ~loc:"escape_string" ?pos ?len str in
    wrap_conn (fun conn -> Stub.escape_string_conn conn str ~pos ~len)

  method escape_bytea ?pos ?len str =
    let pos, len = get_str_pos_len ~loc:"escape_bytea" ?pos ?len str in
    wrap_conn (fun conn -> Stub.escape_bytea_conn conn str ~pos ~len)
end
